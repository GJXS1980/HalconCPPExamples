///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in UTF-8.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////
#include "halconcpp/HalconCpp.h"

using namespace HalconCpp;

namespace HandToEye
{
//Note global variables cannot be shared across exports with different namespace
// Procedure declarations 
// External procedures 
// Chapter: Graphics / Text
// Short Description: Display 'Click 'Run' to continue' in the lower right corner of the screen. 
extern void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box);
// Chapter: Graphics / Text
// Short Description: Write one or multiple text messages. 
extern void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);

// Procedures 
#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_Regions, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_SortedRegions, ho_Contours;
  HObject  ho_Cross, ho_Contour;

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DTranslate;
  HTuple  hv_angle, hv_HomMat2DRotate, hv_Qx, hv_Qy, hv_image_x;
  HTuple  hv_image_y, hv_machine_x, hv_machine_y, hv_HomMat2D;
  HTuple  hv_SerializedItemHandle, hv_FileHandle, hv_HomMat2D_9points;
  HTuple  hv_Machine_x, hv_Machine_y, hv_Width, hv_Height;
  HTuple  hv_WindowHandle, hv_Row, hv_Column, hv_Radius, hv_StartPhi;
  HTuple  hv_EndPhi, hv_PointOrder, hv_Number, hv_Distance;

  //**********************************************************
  //九点标定
  //**********************************************************
  //变换矩阵
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  //平移 (10, 20) 个像素
  HomMat2dTranslate(hv_HomMat2DIdentity, 10, 20, &hv_HomMat2DTranslate);
  //旋转 90 度
  hv_angle = HTuple(90).TupleRad();
  HomMat2dRotate(hv_HomMat2DTranslate, hv_angle, 0, 0, &hv_HomMat2DRotate);
  //测试 (64, 64) → (-84, 74)
  AffineTransPoint2d(hv_HomMat2DRotate, 64, 64, &hv_Qx, &hv_Qy);

  //**********************************************************
  //九点标定案例
  //**********************************************************
  hv_image_x.Clear();
  hv_image_x[0] = 514.335;
  hv_image_x[1] = 515.782;
  hv_image_x[2] = 517.313;
  hv_image_x[3] = 954.505;
  hv_image_x[4] = 955.708;
  hv_image_x[5] = 957.037;
  hv_image_x[6] = 1393.84;
  hv_image_x[7] = 1395.07;
  hv_image_x[8] = 1395.99;

  hv_image_y.Clear();
  hv_image_y[0] = 1807.44;
  hv_image_y[1] = 1347.12;
  hv_image_y[2] = 908.469;
  hv_image_y[3] = 1808.40;
  hv_image_y[4] = 1348.22;
  hv_image_y[5] = 909.957;
  hv_image_y[6] = 1809.31;
  hv_image_y[7] = 1349.42;
  hv_image_y[8] = 911.162;

  hv_machine_x.Clear();
  hv_machine_x[0] = 2.00;
  hv_machine_x[1] = 0.00;
  hv_machine_x[2] = -2.0;
  hv_machine_x[3] = 2.00;
  hv_machine_x[4] = 0.00;
  hv_machine_x[5] = -2.0;
  hv_machine_x[6] = 2.00;
  hv_machine_x[7] = 0.00;
  hv_machine_x[8] = -2.0;

  hv_machine_y.Clear();
  hv_machine_y[0] = 2.00;
  hv_machine_y[1] = 2.00;
  hv_machine_y[2] = 2.00;
  hv_machine_y[3] = 0.00;
  hv_machine_y[4] = 0.00;
  hv_machine_y[5] = 0.00;
  hv_machine_y[6] = -2.0;
  hv_machine_y[7] = -2.0;
  hv_machine_y[8] = -2.0;

  //计算变换矩阵
  //实际上做了一个最小二乘
  VectorToHomMat2d(hv_image_x, hv_image_y, hv_machine_x, hv_machine_y, &hv_HomMat2D);

  //保存变换矩阵
  SerializeHomMat2d(hv_HomMat2D, &hv_SerializedItemHandle);
  OpenFile("transform_vector.hmat", "output_binary", &hv_FileHandle);
  FwriteSerializedItem(hv_FileHandle, hv_SerializedItemHandle);
  CloseFile(hv_FileHandle);

  //读取变换矩阵
  OpenFile("transform_vector.hmat", "input_binary", &hv_FileHandle);
  FreadSerializedItem(hv_FileHandle, &hv_SerializedItemHandle);
  DeserializeHomMat2d(hv_SerializedItemHandle, &hv_HomMat2D_9points);
  CloseFile(hv_FileHandle);

  //测试
  AffineTransPoint2d(hv_HomMat2D_9points, 64, 64, &hv_Qx, &hv_Qy);

  //**********************************************************
  //实际案例分析
  //**********************************************************
  hv_Machine_x = hv_machine_x;
  hv_Machine_y = hv_machine_y;
  // dev_update_window(...); only in hdevelop
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),3);
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"margin");

  ReadImage(&ho_Image, "../img/d15.jpg");
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());

  SetWindowAttr("background_color","black");
  OpenWindow(0,0,hv_Width/4,hv_Height/4,0,"visible","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
    WriteImage(ho_Image, "jpg", 0, "1");

  disp_continue_message(hv_WindowHandle, "black", "true");
  // stop(...); only in hdevelop
  //阈值分割
  Threshold(ho_Image, &ho_Regions, 20, 100);
  //填充
  FillUp(ho_Regions, &ho_Regions);
  //连通区域
  Connection(ho_Regions, &ho_ConnectedRegions);
  //特征选择
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "roundness", "and", 0.95, 
      1);
  //按相对位置排序
  SortRegion(ho_SelectedRegions, &ho_SortedRegions, "first_point", "true", "row");
  if (HDevWindowStack::IsOpen())
    SetColored(HDevWindowStack::GetActive(),12);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_SelectedRegions, HDevWindowStack::GetActive());
    // WriteImage(ho_SelectedRegions, "jpg", 0, "2");
    
  //按 F5 继续
  disp_continue_message(hv_WindowHandle, "black", "true");
  // stop(...); only in hdevelop
  //区域面积和中心点坐标
  //area_center (SortedRegions, Area, Row, Column)
  //最小外接圆
  //smallest_circle (SortedRegions, Row, Column, Radius)

  //圆拟合
  GenContourRegionXld(ho_SortedRegions, &ho_Contours, "center");

  //fit_circle_contour_xld(Contours, Method, GenParamName, GenParamValue, Row, Column, Radius, StartPhi, EndPhi, PointOrder);
  //Contours：输入参数，表示包含轮廓点坐标的 XLD 对象。
  //Method：输入参数，表示拟合方法。常见的方法有 'algebraic'、'geotukey'、'max_min_dist' 等。具体的拟合方法可以参考 HALCON 的文档说明。
  //GenParamName：输入参数，表示附加的通用参数名，用于指定拟合的选项。
  //GenParamValue：输入参数，表示附加的通用参数值，用于设置拟合选项的值。
  //Row、Column：输出参数，表示拟合得到的圆的圆心坐标。
  //Radius：输出参数，表示拟合得到的圆的半径。
  //StartPhi、EndPhi：输出参数，表示拟合得到的圆的起始角度和终止角度。
  //PointOrder：输出参数，表示拟合得到的圆的点的顺序。
  FitCircleContourXld(ho_Contours, "geotukey", -1, 0, 0, 3, 2, &hv_Row, &hv_Column, 
      &hv_Radius, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
  GenCrossContourXld(&ho_Cross, hv_Row, hv_Column, 50, 0.785398);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Cross, HDevWindowStack::GetActive());
    // WriteImage(ho_Cross, "bmp", 0, "3");
  disp_continue_message(hv_WindowHandle, "black", "true");
  // stop(...); only in hdevelop
  //转换矩阵
  //vector_to_hom_mat2d (Row, Column, Machine_x, Machine_y, HomMat2D)

  //**********************************************************
  //验证
  //**********************************************************
  ReadImage(&ho_Image, "../img/d20.jpg");

  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  //按 F5 继续
  disp_continue_message(hv_WindowHandle, "black", "true");
  // stop(...); only in hdevelop
  Threshold(ho_Image, &ho_Regions, 25, 160);
  FillUp(ho_Regions, &ho_Regions);
  Connection(ho_Regions, &ho_ConnectedRegions);
  CountObj(ho_ConnectedRegions, &hv_Number);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "roundness", "and", 0.95, 
      1);
  SortRegion(ho_SelectedRegions, &ho_SortedRegions, "first_point", "true", "row");
  GenContourRegionXld(ho_SortedRegions, &ho_Contours, "center");
  FitCircleContourXld(ho_Contours, "geotukey", -1, 0, 0, 3, 2, &hv_Row, &hv_Column, 
      &hv_Radius, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
  AffineTransPoint2d(hv_HomMat2D, hv_Row, hv_Column, &hv_Qx, &hv_Qy);
  GenCrossContourXld(&ho_Cross, hv_Row, hv_Column, 50, 0.785398);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Cross, HDevWindowStack::GetActive());
    // WriteImage(ho_Cross, "bmp", 0, "ho_Cross_test");
  //画两条线并计算长度
  //横线
  GenContourPolygonXld(&ho_Contour, HTuple(hv_Row[1]).TupleConcat(HTuple(hv_Row[2])), 
      HTuple(hv_Column[1]).TupleConcat(HTuple(hv_Column[2])));
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Contour, HDevWindowStack::GetActive());
    // WriteImage(ho_Contour, "bmp", 0, "ho_Contour");
  DistancePp(HTuple(hv_Qy[1]), HTuple(hv_Qx[1]), HTuple(hv_Qy[2]), HTuple(hv_Qx[2]), 
      &hv_Distance);
  disp_message(hv_WindowHandle, hv_Distance+"cm", "window", (HTuple(hv_Row[1])/4)+10, 
      HTuple(hv_Column[1])/4, "red", "true");
  //竖线
  GenContourPolygonXld(&ho_Contour, HTuple(hv_Row[4]).TupleConcat(HTuple(hv_Row[6])), 
      HTuple(hv_Column[4]).TupleConcat(HTuple(hv_Column[6])));
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Contour, HDevWindowStack::GetActive());
    // WriteImage(ho_Contour, "bmp", 0, "ho_Contour_test");
  DistancePp(HTuple(hv_Qy[4]), HTuple(hv_Qx[4]), HTuple(hv_Qy[6]), HTuple(hv_Qx[6]), 
      &hv_Distance);
  disp_message(hv_WindowHandle, hv_Distance+"cm", "window", HTuple(hv_Row[4])/4, 
      (HTuple(hv_Column[4])/4)+10, "red", "true");
  // dev_update_window(...); only in hdevelop
}

#ifndef NO_EXPORT_APP_MAIN

} // end namespace

int main(int argc, char *argv[])
{
  int ret = 0;
  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#endif
    // Default settings used in HDevelop (can be omitted)
    SetSystem("width", 512);
    SetSystem("height", 512);

    HandToEye::action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            exception.ProcName().TextA(),
            exception.ErrorMessage().TextA());
    ret = 1;
  }
  return ret;
}
namespace HandToEye
{

#endif

#endif

} // end namespace

